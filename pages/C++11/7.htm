<h1>Лямбда-функции и выражения</h1>

<p>В стандартном C++, например, при использовании алгоритмов стандартной библиотеки C++ <tt>sort</tt> и <tt>find</tt>, часто возникает потребность в определении функций-предикатов рядом с местом, где осуществляется вызов этого алгоритма. В языке существует только один механизм для этого: возможность определить класс функтора (передача экземпляра класса, определенного внутри функции, в алгоритмы запрещена (Meyers, Effective STL)). Зачастую данный способ является слишком избыточным и многословным и лишь затрудняет чтение кода. Кроме того, стандартные правила C++ для классов, определённых в функциях, не позволяют использовать их в шаблонах и таким образом делают их применение невозможным.</p>

<p>Очевидным решением проблемы явилось разрешение определения лямбда-выражений и лямбда-функций в C++11. Лямбда-функция определяется следующим образом:</p>

<pre>
<code>[](int x, int y) { return x + y; }</code>
</pre>

<p>Тип возвращаемого значения этой безымянной функции вычисляется как <tt>decltype(x+y)</tt>. Тип возвращаемого значения может быть опущен только в том случае, если лямбда-функция представлена в форме <code>return <em>expression</em></code>. Это ограничивает размер лямбда-функции до одного выражения.</p>

<p>Тип возвращаемого значения может быть указан явно, например:</p>

<pre>
<code>[](int x, int y) -&gt; int { int z = x + y; return z; }</code>
</pre>

<p>В этом примере создаётся временная переменная <tt>z</tt> для хранения промежуточного значения. Как и в нормальных функциях, это промежуточное значение не сохраняется между вызовами.</p>

<p>Тип возвращаемого значения может быть полностью опущен, если функция не возвращает значения (то есть тип возвращаемого значения &mdash; <tt>void</tt>)</p>

<p>Также возможно использование ссылок на переменные, определённые в той же области видимости, что и лямбда-функция. Набор таких переменных обычно называют замыканием. Замыкания определяются и используются следующим образом:</p>

<pre>
<code>std::vector&lt;int&gt; someList;
int total = 0;
std::for_each(someList.begin(), someList.end(), [&amp;total](int x) {
  total += x;
});
std::cout &lt;&lt; total;</code>
</pre>

<p>Это отобразит сумму всех элементов в списке. Переменная <tt>total</tt> хранится как часть замыкания лямбда-функции. Так как она ссылается на стековую переменную <tt>total</tt>, она может менять её значение.</p>

<p>Переменные замыкания для локальных переменных могут быть также определены без использования символа ссылки <em>&amp;</em>, что означает, что функция будет копировать значение. Это вынуждает пользователя заявлять о намерении сослаться на локальную переменную или скопировать её.</p>

<p>Для лямбда-функций, гарантированно исполняемых в области их видимости, возможно использование всех стековых переменных без необходимости явных ссылок на них:</p>

<pre>
<code>std::vector&lt;int&gt; someList;
int total = 0;
std::for_each(someList.begin(), someList.end(), [&amp;](int x) {
  total += x;
});
</code></pre>

<p>Способы внутренней реализации могут различаться, но предполагается, что лямбда-функция сохранит указатель на стек функции, в которой она создана, а не будет работать с отдельными ссылками на переменные стека.</p>

<p>Если вместо <code>[&amp;]</code> используется <code>[=]</code>, все используемые переменные будут скопированы, что позволяет использовать лямбда-функцию вне области действия исходных переменных.</p>

<p>Способ передачи по умолчанию можно также дополнить списком отдельных переменных. Например, если необходимо передать большинство переменных по ссылке, а одну по значению, можно использовать следующую конструкцию:</p>

<pre>
<code>int total = 0;
int value = 5;
[&amp;, value](int x) { total += (x * value); } (1); //(1) вызов лямбда-функции с передачей значения 1</code>
</pre>

<p>Это вызовет передачу <tt>total</tt> по ссылке, а <tt>value</tt> &mdash; по значению.</p>

<p>Если лямбда-функция определена в методе класса, она считается дружественной этому классу. Такие лямбда-функции могут использовать ссылку на объект типа класса и обращаться к его внутренним полям:</p>

<pre>
<code>[](SomeType *typePtr) { typePtr-&gt;SomePrivateMemberFunction(); }</code>
</pre>

<p>Это будет работать только если областью создания лямбда-функции является метод класса <tt>SomeType</tt>.</p>

<p>Особым образом реализована работа с указателем <tt>this</tt> на объект, с которым взаимодействует текущий метод. Он должен быть явно обозначен в лямбда-функции:</p>

<pre>
<code>[this]() { this-&gt;SomePrivateMemberFunction(); }</code>
</pre>

<p>Использование формы <code>[&amp;]</code> или <code>[=]</code> лямбда-функции делает <tt>this</tt> доступным автоматически.</p>

<p>Тип лямбда-функций зависит от реализации; имя этого типа доступно только компилятору. Если необходимо передать лямбда-функцию в качестве параметра, она должна быть шаблонного типа, либо сохранена с использованием <tt>std::function</tt>. Ключевое слово <tt>auto</tt> позволяет локально сохранить лямбда-функцию:</p>

<pre>
<code>auto myLambdaFunc = [this]() { this-&gt;SomePrivateMemberFunction(); };</code>
</pre>

<p>Кроме того, если функция не принимает аргументов, то <code>()</code> можно опустить:</p>

<pre>
<code>auto myLambdaFunc = []{ std::cout &lt;&lt; &quot;hello&quot; &lt;&lt; std::endl; };</code>
</pre>
