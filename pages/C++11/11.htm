<h1>Явное замещение виртуальных функций и финальность</h1>

<p>Возможна ситуация, когда сигнатура виртуального метода изменена в базовом классе или изначально неправильно задана в производном классе. В таких случаях данный метод в классе-наследнике не будет замещать соответствующий метод базового класса. Так что если программист должным образом не изменит сигнатуру метода во всех классах-наследниках, метод может быть вызван некорректно в процессе выполнения программы. Например:</p>

<pre>
<code>struct Base {
    virtual void some_func();
};

struct Derived : Base {
    void sone_func();
};</code>
</pre>

<p>Здесь в имени виртуальной функции, объявленной в производном классе, допущена ошибка, поэтому такая функция не будет замещать <code>Base::some_func</code> и, соответственно, не будет вызываться полиморфно через указатель или ссылку на базовый подобъект.</p>

<p>В C++11 будет добавлена возможность отследить подобные проблемы на этапе компиляции (а не на этапе выполнения). Для обратной совместимости данная возможность является опциональной. Новый синтаксис представлен ниже:</p>

<pre>
<code>struct B
{
    virtual void some_func();
    virtual void f(int);
    virtual void g() const;
};

struct D1 : public B
{
    void sone_func() override;          // ошибка: неверное имя функции
    void f(int) override;               // OK: замещает такую же функцию в базовом классе
    virtual void f(long) override;      // ошибка: несоответствие типа параметра
    virtual void f(int) const override; // ошибка: несоответствие cv-квалификации функции
    virtual int f(int) override;        // ошибка: несоответствие типа возврата
    virtual void g() const final;       // OK: замещает такую же функцию в базовом классе
    virtual void g(long);               // OK: новая виртуальная функция
};

struct D2 : D1
{
    virtual void g() const;             // ошибка: попытка замещения финальной функции
};</code>
</pre>

<p>Наличие у виртуальной функции спецификатора <code>final</code> означает, что её дальнейшее замещение невозможно. Кроме того, класс, определённый со спецификатором final, не может использоваться в качестве базового класса:</p>

<pre>
<code>struct F final
{
    int x, y;
};

struct D : F  // ошибка: наследование от final классов запрещено
{
    int z;
};</code>
</pre>
