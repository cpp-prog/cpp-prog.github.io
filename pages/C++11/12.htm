<h1>Константа нулевого указателя</h1>

<p>Со времён появления Си в 1972, константа 0 играла двойную роль целого числа и нулевого указателя. Одним из способов борьбы с этой неопределённостью, свойственной языку Си, служит макрос <code>NULL</code>, который обычно осуществляет подстановку <code>((void*)0)</code> или <code>0</code>. C++ в этом плане отличается от Си, позволяя использовать только <code>0</code> в качестве константы нулевого указателя. Это приводит к плохому взаимодействию с перегрузкой функций:</p>

<pre>
<code>void foo(char *);
void foo(int);</code>
</pre>

<p>Если макрос <code>NULL</code> определён как <code>0</code> (что является обычным для C++), строка <code>foo(NULL);</code> приведёт к вызову <code>foo(int)</code>, а не <code>foo(char *)</code>, как можно предположить при беглом просмотре кода, что почти наверняка не совпадает с планами программиста.</p>

<p>Одним из новшеств C++11 является новое ключевое слово для описания константы нулевого указателя&nbsp;&mdash; <code>nullptr</code>. Данная константа имеет тип <code>std::nullptr_t</code>, который можно неявно конвертировать в тип любого указателя и сравнить с любым указателем. Неявная конверсия в целочисленный тип недопустима, за исключением <code>bool</code>. В исходном предложении стандарта не допускалось неявной конверсии в булевый тип, но рабочая группа разработчиков стандарта разрешила такое преобразования в целях совместимости с обычными типами указателей. Предлагаемая формулировка была изменена после единогласного голосования в июне 2008.</p>

<p>В целях обеспечения обратной совместимости, константа <code>0</code> также может использоваться в качестве нулевого указателя.</p>

<pre>
<code>char *pc = nullptr;     // верно
int  *pi = nullptr;     // верно
bool   b = nullptr;     // верно. b = false.
int    i = nullptr;     // ошибка

foo(nullptr);           // вызывает foo(char *), а не foo(int);</code></pre>
