<h1>Ссылки на временные объекты и семантика переноса (Rvalue Reference/Move semantics)</h1>

<p>По стандарту C++ временный объект, появившийся в результате вычисления выражения, можно передавать в функции, но только по константной ссылке (const &amp;). Функция не в состоянии определить, можно ли рассматривать переданный объект как временный и допускающий модификацию (константный объект, который тоже может быть передан по такой ссылке, нельзя модифицировать (легально)). Это не проблема для простейших структур наподобие complex, но для сложных типов, требующих выделения-освобождения памяти, уничтожение временного объекта и создание постоянного может отнимать много времени, в то время как можно было бы просто напрямую передать указатели.</p>

<p>В C++11 появился новый тип ссылки &mdash; rvalue-ссылка. Его объявление следующее: type &amp;&amp;. Новые правила разрешения перегрузки позволяют использовать разные перегруженные функции для неконстантных временных объектов, обозначаемых посредством rvalues, и для всех остальных объектов. Данное нововведение позволяет реализовывать семантику переноса (Move semantics).</p>

<p>Например, std::vector &mdash; это простая обёртка вокруг Си-массива и переменной, хранящей его размер. Конструктор копирования std::vector::vector(const vector &amp;x) создаст новый массив и скопирует информацию; конструктор переноса std::vector::vector(vector &amp;&amp;x) может просто обменяться указателями и переменными, содержащими длину.</p>

<p>Пример объявления.</p>

<pre>
<code>    template&lt;class T&gt; class vector
    {
       vector (const vector &amp;);              // Конструктор копирования (медленный)
       vector (vector &amp;&amp;);                   // Конструктор переноса из временного объекта (быстрый)
       vector &amp; operator = (const vector &amp;); // Обычное присваивание (медленное)
       vector &amp; operator = (vector &amp;&amp;);      // Перенос временного объекта (быстрый)
    };</code></pre>
