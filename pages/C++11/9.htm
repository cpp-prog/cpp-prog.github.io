<h1>Улучшение конструкторов объектов</h1>

<p>Стандартный C++ не допускает вызова одних конструкторов класса из других конструкторов этого же класса; каждый конструктор должен полностью инициализировать все члены класса либо вызывать для этого методы класса. Неконстантные члены класса не могут быть инициализированы в месте объявления этих членов.</p>

<p>C++11 избавляет от этих проблем.</p>

<p>Новый стандарт позволяет вызывать одни конструкторы класса из других (так называемая делегация). Это позволяет писать конструкторы, использующие поведение других конструкторов без внесения дублирующего кода.</p>

<p>Пример:</p>

<pre>
<code>class SomeType  {
    int number;

public:
    SomeType(int new_number) : number(new_number) {}
    SomeType() : SomeType(42) {}
};</code>
</pre>

<p>Из примера видно, что конструктор <code>SomeType</code> без аргументов вызывает конструктор того же класса с целочисленным аргументом для инициализации переменной <code>number</code>. Похожего эффекта можно было добиться, указав инициализирующее значение 42 для этой переменной прямо при её объявлении.</p>

<pre>
<code>class SomeType  {
    int number = 42;

public:
    SomeType() {}
    explicit SomeType(int new_number) : number(new_number) {}
};</code>
</pre>

<p>Любой конструктор класса будет инициализировать <code>number</code> значением 42, если он сам не присваивает ей другое значение.</p>

<p>Примером языков, которые так же решают эти проблемы служат Java, C# и D.</p>

<p>Следует заметить, что если в C++03 объект считается до конца созданным когда его конструктор завершает выполнение, то в C++11 после выполнения хотя бы одного делегирующего конструктора остальные конструкторы будут работать уже над полностью сконструированным объектом. Несмотря на это объекты производного класса начнут конструироваться только после выполнения всех конструкторов базовых классов.</p>
