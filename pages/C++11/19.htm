<h1>Новые строковые литералы</h1>

<p>C++03 предлагал два типа строковых литералов. Первый тип, строка, заключённая в двойные кавычки, представляет собой массив с завершающим нулём (null-terminated) типа <code>const char</code>. Второй тип, определённый как <code>L&quot;&quot;</code>, представляет собой массив с завершающим нулём типа <code>const wchar_t</code>, где <code>wchar_t</code> является широким символом неопределённых размеров и семантики. Ни один из типов литералов не предполагает поддержку строковых литералов UTF-8, UTF-16, или любого другого типа Unicode кодировок.</p>

<p>Определение типа <code>char</code> было модифицировано до явного высказывания, что он по меньшей мере размера, необходимого для хранения восьми-битной кодировки UTF-8, и достаточно большой, чтобы содержать любой символ из набора символов времени выполнения. Ранее в стандарте этот тип определялся как один символ, позже, следуя стандарту языка Си, он стал гарантированно занимать как минимум 8 бит.</p>

<p>Есть три Unicode кодировки, которые поддерживаются в стандарте C++11:&nbsp;UTF-8, UTF-16, и UTF-32. В дополнение к вышеуказанным изменениям встроенного символьного типа <code>char</code>, в C++11 добавлено два новых символьных типа: <code>char16_t</code> и <code>char32_t</code>. Они предназначены для хранения UTF-16 и UTF-32 символов соответственно.</p>

<p>Ниже показано, как создать строковые литералы для каждой из этих кодировок:</p>

<pre>
<code>u8&quot;I&#39;m a UTF-8 string.&quot;
u&quot;This is a UTF-16 string.&quot;
U&quot;This is a UTF-32 string.&quot;
</code></pre>

<p>Типом первой строки является обычный <code>const char[]</code>. Тип второй строки&nbsp;&mdash; <code>const char16_t[]</code>. Тип третьей строки&nbsp;&mdash; <code>const char32_t[]</code>.</p>

<p>При построении строковых литералов в стандарте Unicode, часто полезно вставить Unicode код прямо в строку. Для этого C++11 предлагает следующий синтаксис:</p>

<pre>
<code>u8&quot;This is a Unicode Character: \u2018.&quot;
u&quot;This is a bigger Unicode Character: \u2018.&quot;
U&quot;This is a Unicode Character: \U00002018.&quot;
</code></pre>

<p>Число после <code>\u</code> должно быть шестнадцатеричным; не нужно использовать префикс <code>0x</code>. Идентификатор <code>\u</code> означает 16-битный Unicode код; для ввода 32-битного кода используется <code>\U</code> и 32-битное шестнадцатеричное число. Могут быть введены только действительные Unicode коды. Например, коды в диапазоне U+D800-U+DFFF запрещены, так как они зарезервированы для суррогатных пар в кодировке UTF-16.</p>

<p>Также иногда полезно избегать экранирования строк вручную, особенно при использовании литералов XML файлов, скриптовых языков программирования, или регулярных выражений. Для этих целей C++11 поддерживает &laquo;сырые&raquo; строковые литералы:</p>

<pre>
<code>R&quot;(The String Data \ Stuff &quot; )&quot;
R&quot;delimiter(The String Data \ Stuff &quot; )delimiter&quot;
</code></pre>

<p>В первом случае всё между <code>&quot;(</code> и <code>)&quot;</code> является частью строки. Символы <code>&quot;</code> и <code>\</code> не нужно экранировать. Во втором случае <code>&quot;delimiter(</code> начинает строку, и она заканчивается только при достижении <code>)delimiter&quot;</code>. Строка <code>delimiter</code> может быть любой строкой длиной до 16 символов, включая пустую строку. Эта строка не может содержать пробелы, управляющие символы, &#39;<code>(</code>&#39;, &#39;<code>)</code>&#39;, или символ &#39;<code>\</code>&#39;. Использование этой строки-разделителя позволяет использовать символ &#39;<code>)</code>&#39; в &laquo;сырых&raquo; строковых литералах. Например, <code>R&quot;delimiter((a-z))delimiter&quot;</code> эквивалентно <code>&quot;(a-z)&quot;</code>.<sup><a class="external autonumber" href="https://ru.wikipedia.org/wiki/C%2B%2B11#endnote_n3000">[3]</a></sup></p>

<p>&laquo;Сырые&raquo; строковые литералы могут быть объединены с литералом из расширенного набора (префикс <code>L&quot;&quot;</code>) или любыми префиксами Unicode литералов.</p>

<pre>
<code>LR&quot;(Raw wide string literal \t (without a tab))&quot;
u8R&quot;XXX(I&#39;m a &quot;raw UTF-8&quot; string.)XXX&quot;
uR&quot;*(This is a &quot;raw UTF-16&quot; string.)*&quot;
UR&quot;(This is a &quot;raw UTF-32&quot; string.)&quot;
</code></pre>
