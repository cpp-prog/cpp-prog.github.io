<h1>Универсальная инициализация</h1>

<p>В стандарте C++ содержится ряд проблем, связанных с инициализацией типов. Существует несколько путей инициализации типов и не все они приводят к одинаковым результатам. К примеру, традиционный синтаксис инициализирующего конструктора может выглядеть как описание функции, и нужно предпринять дополнительные меры, чтобы компилятор не ошибся при анализе. Только агрегирующие типы и POD типы могут быть инициализированы с помощью инициализаторов агрегатов (вида <code>SomeType var = {/*stuff*/};</code>).</p>

<p>C++11 предоставляет синтаксис, позволяющий использовать единую форму инициализации для всех видов объектов с помощью расширения синтаксиса списков инициализации:</p>

<pre>
<code>struct BasicStruct {
    int x;
    double y;
};

struct AltStruct {
    AltStruct(int x, double y) : x_(x), y_(y) {}

private:
    int x_;
    double y_;
};

BasicStruct var1{5, 3.2};
AltStruct var2{2, 4.3};</code></pre>

<p>Инициализация <tt>var1</tt> работает точно так же, как и при инициализации агрегатов, то есть, каждый объект будет инициализирован копированием соответствующего значения из списка инициализации. При необходимости будет применено неявное преобразование типов. Если нужного преобразования не существует, исходный код будет считаться некорректным. Во время инициализации <tt>var2</tt> будет вызван конструктор.</p>

<p>Предоставлена возможность писать подобный код:</p>

<pre>
<code>struct IdString
{
    std::string name;
    int identifier;
};

IdString GetString()
{
    return {&quot;SomeName&quot;, 4}; // Обратите внимание на отсутствие явного указания типов
}</code>
</pre>

<p>Универсальная инициализация не заменяет полностью синтаксиса инициализации с помощью конструктора. Если в классе есть конструктор, принимающий в качестве аргумента список инициализации (<tt>ИмяТипа(initializer_list&lt;SomeType&gt;);</tt>), он будет иметь более высокий приоритет по сравнению с другими возможностями создания объектов. Например, в C++11 <tt>std::vector</tt> содержит конструктор, принимающий в качестве аргумента список инициализации:</p>

<pre>
<code>std::vector&lt;int&gt; theVec{4};</code>
</pre>

<p>Данный код приведёт к вызову конструктора, принимающего в качестве аргумента список инициализации, а не конструктор с одним параметром, создающий контейнер заданного размера. Для вызова этого конструктора пользователь должен будет использовать стандартный синтаксис вызова конструктора.</p>
