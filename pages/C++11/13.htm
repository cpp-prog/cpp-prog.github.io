<h1>Перечисления со строгой типизацией</h1>

<p>В стандартном C++ перечисления не являются типобезопасными. В действительности они представлены целыми числами, несмотря на то, что сами типы перечислений различны между собой. Это позволяет производить сравнения между двумя значениями из разных перечислений. Единственной возможностью, которую предлагает C++03 для защиты перечислений, является запрет на неявное преобразование целых чисел или элементов одного перечисления в элементы другого перечисления. Кроме того, способ представления в памяти (целочисленный тип) зависит от реализации и поэтому не является переносимым. Наконец, элементы перечислений имеют общую область видимости, что приводит к невозможности создания элементов с одинаковым именем в разных перечислениях.</p>

<p>C++11 предлагает специальную классификацию этих перечислений, свободную от вышеописанных недостатков. Для описания таких перечислений используется объявление <code>enum class</code> (также возможно использование <code>enum struct</code> в качестве синонима):</p>

<pre>
<code>enum class Enumeration {
    Val1,
    Val2,
    Val3 = 100,
    Val4, /* = 101 */
};</code>
</pre>

<p>Такое перечисление является типобезопасным. Элементы классового перечисления невозможно неявно преобразовать в целые числа. Как следствие, сравнение с целыми числами также невозможно (выражение <code>Enumeration::Val4 == 101</code> приводит к ошибке компиляции).</p>

<p>Тип классового перечисления теперь не зависит от реализации. По умолчанию, как в случае выше, таким типом является <code>int</code>, но в иных случаях тип может быть задан вручную следующим образом:</p>

<pre>
<code>enum class Enum2 : unsigned int {Val1, Val2};</code>
</pre>

<p>Область действия элементов перечислений определяется областью действия имени перечисления. Использование имён элементов требует указания имени классового перечисления. Так, например, значение <code>Enum2::Val1</code> определено, а значение <code>Val1</code>&nbsp;&mdash; не определено.</p>

<p>Кроме того, C++11 предлагает возможность указания явной области видимости и низлежащего типа и для обычных перечислений:</p>

<pre>
<code>enum Enum3 : unsigned long {Val1 = 1, Val2};</code>
</pre>

<p>В данном примере имена элементов перечисления определены в пространстве перечисления (Enum3::Val1), но для обеспечения обратной совместимости имена элементов также доступны в общей области видимости.</p>

<p>Также в C++11 возможно предварительное объявление перечислений. В предыдущих версиях С++ это было невозможным, поскольку размер перечисления зависел от его элементов. Такие объявления можно использовать только в тех случаях, когда размер перечисления указан (явно или неявно):</p>

<pre>
<code>enum Enum1;                   // неверно для C++ и C++11; низлежащий тип не может быть определён
enum Enum2 : unsigned int;    // верно для C++11, низлежащий тип указан явно
enum class Enum3;             // верно для C++11, низлежащий тип&nbsp;&mdash; int
enum class Enum4 : unsigned int; // верно для C++11.
enum Enum2 : unsigned short;  // неверно для C++11, поскольку Enum2 ранее объявлен с иным низлежащим типом</code>
</pre>
