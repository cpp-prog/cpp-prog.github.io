<h1>Вывод типов</h1>

<p>В стандартном C++ (и C) тип переменной должен быть явно указан. Однако, после появления шаблонных типов и техник шаблонного метапрограммирования, тип некоторых значений, в особенности возвращаемых значений функций, не может быть легко задан. Это приводит к сложностям при хранении промежуточных данных в переменных, иногда может потребоваться знание внутреннего устройства конкретной библиотеки метапрограммирования.</p>

<p>C++11 предлагает два способа для смягчения этих проблем. Во-первых, определение явно инициализируемой переменной может содержать ключевое слово <tt>auto</tt>. Это приведёт к тому, что будет создана переменная типа инициализирующего значения:</p>

<pre>
<code>auto someStrangeCallableType = std::bind(&amp;SomeFunction, _2, _1, someObject);
auto otherVariable = 5;</code>
</pre>

<p>Типом <tt>someStrangeCallableType</tt> станет тот тип, который возвращает конкретная реализация шаблонной функции <code>std::bind</code> для заданных аргументов. Данный тип будет легко определён компилятором во время выполнения семантического анализа, а вот программисту для определения типа пришлось бы провести ряд изысканий.</p>

<p>Тип <tt>otherVariable</tt> также чётко определён, однако, так же легко может быть определён и программистом. Этот тип&nbsp;&mdash; <tt>int</tt>, такой же как у целочисленной константы.</p>

<p>Кроме того, для определения типа выражения во время компиляции может быть использовано ключевое слово decltype. Например:</p>

<pre>
<code>int someInt;
decltype(someInt) otherIntegerVariable = 5;</code>
</pre>

<p>Использование <tt>decltype</tt> наиболее полезно совместно с <tt>auto</tt>, так как тип переменной, описанной как <tt>auto</tt>, известен только компилятору. Кроме того, использование <tt>decltype</tt> может быть весьма полезным в выражениях, использующих перегрузку операторов и специализацию шаблонов.</p>

<p><code>auto</code> также может быть использован для уменьшения избыточности кода. Например, вместо:</p>

<pre>
<code>for (vector&lt;int&gt;::const_iterator itr = myvec.cbegin(); itr != myvec.cend(); ++itr)</code>
</pre>

<p>программист сможет написать:</p>

<pre>
<code>for (auto itr = myvec.cbegin(); itr != myvec.cend(); ++itr)</code>
</pre>

<p>Разница становится особенно заметной, когда программист использует большое число различных контейнеров, несмотря на то, что и сейчас существует хороший путь для уменьшения избыточного кода&nbsp;&mdash; использование <code>typedef</code>.</p>

<p>Тип, помеченный как <tt>decltype</tt>, может отличаться от типа выведенного с помощью <tt>auto</tt>.</p>

<pre>
<code>#include &lt;vector&gt;
int main()
{
  const std::vector&lt;int&gt; v(1);
  auto a = v[0];        // тип a - int  
  decltype(v[0]) b = 1; // тип b - const int&amp; (возвращаемое значение
                        // std::vector&lt;int&gt;::operator[](size_type) const)
  auto c = 0;           // тип c - int   
  auto d = c;           // тип d - int            
  decltype(c) e;        // тип e - int, тип сущности, именованной как c 
  decltype((c)) f = c;  // тип f - int&amp;, так как (c) является lvalue
  decltype(0) g;        // тип g - int, так как 0 является rvalue
}</code>
</pre>
