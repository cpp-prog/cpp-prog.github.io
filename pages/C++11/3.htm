<h1>Списки инициализации</h1>

<p>Концепция списков инициализации пришла в C++ из C. Идея состоит в том, что структура или массив могут быть созданы передачей списка аргументов в порядке, соответствующем порядку определения членов структуры. Списки инициализации рекурсивны, что позволяет их использовать для массивов структур и структур, содержащих вложенные структуры.</p>

<pre>
<code>    struct Object
    {
        float first;
        int second;
    };

    Object scalar = {0.43f, 10}; // один объект, с first=0.43f и second=10
    Object anArray[] = {{13.4f, 3}, {43.28f, 29}, {5.934f, 17}}; // массив из трёх объектов</code></pre>

<p>Списки инициализации очень полезны для статических списков и в тех случаях, когда требуется инициализировать структуру определённым значением. C++ также содержит конструкторы, которые могут содержать общую часть работы по инициализации объектов. Стандарт C++ позволяет использовать списки инициализации для структур и классов при условии, что те соответствуют определению простого типа данных (Plain Old Data &mdash; POD). Классы, не являющиеся POD, не могут использовать для инициализации списки инициализации, в том числе это касается и стандартных контейнеров C++, таких, как векторы.</p>

<p>C++11 связал концепцию списков инициализации и шаблонный класс, названный std::initializer_list. Это позволило конструкторам и другим функциям получать списки инициализации в качестве параметров. Например:</p>

<pre>
<code>    class SequenceClass
    {
    public:
      SequenceClass(std::initializer_list&lt;int&gt; list);
    };</code></pre>

<p>Данное описание позволяет создать SequenceClass из последовательности целых чисел следующим образом:</p>

<pre>
<code>    SequenceClass someVar = {1, 4, 5, 6};</code></pre>

<p>Здесь демонстрируется работа особого вида конструктора для списка инициализации. Классы, содержащие подобные конструкторы, обрабатываются особым образом во время инициализации (см. ниже).</p>

<p>Класс std::initializer_list&lt;&gt; определён в стандартной библиотеке C++11. Однако, объекты данного класса могут быть созданы компилятором C++11 только статически с использованием синтаксиса со скобками {}. Список может быть скопирован после создания, однако, это будет копированием по ссылке. Список инициализации является константным: ни его члены, ни их данные не могут быть изменены после создания.</p>

<p>Так как std::initializer_list&lt;&gt; является полноценным типом, он может быть использован не только в конструкторах. Обычные функции могут получать типизированные списки инициализации в качестве аргумента, например:</p>

<pre>
<code>    void FunctionName(std::initializer_list&lt;float&gt; list);

    FunctionName({1.0f, -3.45f, -0.4f});</code></pre>

<p>Стандартные контейнеры могут быть инициализированы следующим образом:</p>

<pre>
<code>    std::vector&lt;std::string&gt; v = { &quot;xyzzy&quot;, &quot;plugh&quot;, &quot;abracadabra&quot; };
    std::vector&lt;std::string&gt; v{ &quot;xyzzy&quot;, &quot;plugh&quot;, &quot;abracadabra&quot; };</code></pre>
