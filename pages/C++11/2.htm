<h1>Обобщённые константные выражения</h1>

<p>В C++ всегда присутствовала концепция константных выражений. Так, выражения типа 3+4 всегда возвращали одни и те же результаты, не вызывая никаких побочных эффектов. Сами по себе константные выражения предоставляют компиляторам C++ удобные возможности по оптимизации результата компиляции. Компиляторы вычисляют результаты таких выражений только на этапе компиляции и сохраняют уже вычисленные результаты в программе. Таким образом, подобные выражения вычисляются только раз. Также существует несколько случаев, в которых стандарт языка требует использования константных выражений. Такими случаями, например, могут быть определения внешних массивов или значения перечислений (enum).</p>

<pre>
<code>    int GiveFive() {return 5;}

    int some_value[GiveFive() + 7]; // создание массива 12 целых; запрещено в C++</code></pre>

<p>Вышеуказанный код запрещён в C++, поскольку GiveFive() + 7 формально не является константным выражением, известным на этапе компиляции. Компилятору на тот момент просто не известно, что функция на самом деле возвращает константу во время исполнения. Причиной таких рассуждений компилятора является то, что эта функция может повлиять на состояние глобальной переменной, вызвать другую неконстантную функцию времени исполнения и т. д.</p>

<p>C++11 вводит ключевое слово constexpr, которое позволяет пользователю гарантировать, что или функция или конструктор объекта возвращает константу времени компиляции. Код выше может быть переписан следующим образом:</p>

<pre>
<code>    constexpr int GiveFive() {return 5;}

    int some_value[GiveFive() + 7]; // создание массива 12 целых; разрешено в C++11</code></pre>

<p>Такое ключевое слово позволяет компилятору понять и удостовериться в том, что GiveFive возвращает константу.</p>

<p>Использование constexpr порождает очень жёсткие ограничения на действия функции:</p>

<p>&nbsp;&nbsp;&nbsp; такая функция должна возвращать значение;</p>

<ul>
	<li>&nbsp;&nbsp;&nbsp; тело функции должно быть вида return выражение;</li>
	<li>&nbsp;&nbsp;&nbsp; выражение должно состоять из констант и/или вызовов других constexpr-функций;</li>
	<li>&nbsp;&nbsp;&nbsp; функция, обозначенная constexpr, не может использоваться до определения в текущей единице компиляции.</li>
</ul>

<p>В предыдущей версии стандарта в константных выражениях можно было использовать переменные только целого типа или типа перечисления. В C++11 это ограничение снято для переменных перед определением которых стоит ключевое слово constexpr:</p>

<pre>
<code>    constexpr double accelerationOfGravity = 9.8;
    constexpr double moonGravity = accelerationOfGravity / 6;</code></pre>

<p>Такие переменные уже неявно считаются обозначенными ключевым словом const. В них могут содержаться только результаты константных выражений или конструкторы таких выражений.</p>

<p>В случае необходимости конструирования константных значений из типов, определённых пользователем, конструкторы таких типов также могут быть описаны с помощью constexpr. Конструктор константных выражений, подобно константным функциям, также должен быть определён до момента первого его использования в текущей единице компиляции. У такого конструктора должно быть пустое тело, а также такой конструктор должен инициализировать члены своего типа только константами.</p>
