<h1>C ++ - Базовый ввод/вывод</h1>

<div class="tutorial-content">
<p>Стандартные библиотеки C ++ предоставляют расширенный набор возможностей ввода / вывода, которые мы увидим в последующих главах.&nbsp;В этой главе будут рассмотрены основные и наиболее распространенные операции ввода-вывода, необходимые для программирования на C ++.</p>

<p>C ++ I / O происходит в потоках, которые представляют собой последовательности байтов.&nbsp;Если байты поступают с устройства, такого как клавиатура, дисковод или сетевое соединение и т. д. В основную память, это называется&nbsp;<strong>операцией ввода,</strong>&nbsp;и если байты поступают из основной памяти в устройство, такое как экран дисплея, принтер, дисковод , или сетевое соединение и т. д., это называется&nbsp;<strong>операцией вывода</strong>&nbsp;.</p>

<h2>Файлы заголовков библиотеки ввода-вывода</h2>

<p>Для программ на C ++ важны следующие файлы заголовков -</p>

<blockquote>
<p><code>&lt;Iostream&gt;</code></p>
</blockquote>

<p>Этот файл определяет&nbsp;объекты <code>cin, cout, cerr</code>&nbsp;и&nbsp;<code>clog</code>&nbsp;, которые соответствуют стандартным входным потокам, стандартным потокам вывода, потоку стандартной буферизации без буферизации и потоку стандартной буферизации, соответственно.</p>

<blockquote>
<p><code>&lt;Iomanip&gt;</code></p>
</blockquote>

<p>Этот файл объявляет услуги ,&nbsp;полезные для выполнения отформатированного ввода / вывода с помощью&nbsp;так называемым параметризованным потоком манипуляторами, такие как&nbsp;<code>setw</code>&nbsp;и&nbsp;<code>setprecision</code>&nbsp;.</p>

<p><code>&lt;Fstream&gt;</code></p>

<p>Этот файл объявляет службы для обработки файлов, управляемых пользователем.&nbsp;Мы обсудим это подробно в главе &laquo;Файл и поток&raquo;.</p>

<h2>Стандартный выходной поток (cout)</h2>

<p><strong>Предопределенный</strong>&nbsp;объект&nbsp;<strong>cout</strong>&nbsp;является экземпляром&nbsp;класса&nbsp;<strong>ostream</strong>&nbsp;.&nbsp;Сообщается, что объект cout &laquo;подключен к&raquo; стандартным устройствам вывода, который обычно является экраном дисплея.&nbsp;<strong>СоиЬ</strong>&nbsp;используется в сочетании с оператором вставки потока, который записывается в&nbsp;виде &lt;&lt; которые являются два меньше ,&nbsp;чем знаки ,&nbsp;как показано в следующем примере.</p>

<blockquote>
<pre>
<code>#include &lt;iostream&gt;
 
using namespace std;
 
int main() {
   char str[] = &quot;Hello C++&quot;;
 
   cout &lt;&lt; &quot;Value of str is : &quot; &lt;&lt; str &lt;&lt; endl;
}</code></pre>
</blockquote>

<p>Когда приведенный выше код компилируется и выполняется, он производит следующий результат:</p>

<blockquote>
<pre>
<code>Value of str is : Hello C++</code></pre>
</blockquote>

<p>Компилятор C ++ также определяет тип данных переменной, подлежащей выводу, и выбирает соответствующий оператор вставки потока для отображения значения.&nbsp;Оператор &lt;&lt; перегружен для вывода элементов данных встроенных типов <code>integer, float, double, string</code> и значений указателя.</p>

<p>Оператор ввода <code>&lt;&lt;</code> может использоваться более одного раза в одном выражении, как показано выше, и&nbsp;<code>endl&nbsp;</code>используется для добавления новой строки в конце строки.</p>

<h2>Стандартный входной поток (cin)</h2>

<p>Предопределенный объект&nbsp;<strong>cin</strong>&nbsp;является экземпляром&nbsp;класса&nbsp;<strong>istream</strong>&nbsp;.&nbsp;Говорят, что объект cin прикреплен к стандартным устройствам ввода, которые обычно являются клавиатурой.&nbsp;<strong>CIN</strong>&nbsp;используется в сочетании с оператором экстракции потока, который записывается как &gt;&gt; ,&nbsp;которые являются два больше ,&nbsp;чем знаки ,&nbsp;как показано в следующем примере.</p>

<blockquote>
<pre>
<code>#include &lt;iostream&gt;
 
using namespace std;
 
int main() {
   char name[50];
 
   cout &lt;&lt; &quot;Please enter your name: &quot;;
   cin &gt;&gt; name;
   cout &lt;&lt; &quot;Your name is: &quot; &lt;&lt; name &lt;&lt; endl;
 
}</code></pre>
</blockquote>

<p>Когда вышеуказанный код скомпилирован и выполнен, он предложит вам ввести имя.&nbsp;Вы вводите значение, а затем нажмите Enter, чтобы увидеть следующий результат -</p>

<blockquote>
<pre>
<code>Please enter your name: cplusplus
Your name is: cplusplus</code></pre>
</blockquote>

<p>Компилятор C ++ также определяет тип данных введенного значения и выбирает соответствующий оператор извлечения потока для извлечения значения и сохранения его в данных переменных.</p>

<p>Оператор извлечения потока &gt;&gt; может использоваться более одного раза в одном выражении.&nbsp;Чтобы запросить более одного элемента данных, вы можете использовать следующее:</p>

<blockquote>
<pre>
<code>cin &gt;&gt; name &gt;&gt; age;</code></pre>
</blockquote>

<p>Это будет эквивалентно следующим двум утверждениям:</p>

<blockquote>
<pre>
<code>cin &gt;&gt; name;
cin &gt;&gt; age;</code></pre>
</blockquote>

<h2>Стандартный поток ошибок (cerr)</h2>

<p><strong>Предопределенный</strong>&nbsp;объект&nbsp;<strong>cerr</strong>&nbsp;является экземпляром&nbsp;класса&nbsp;<strong>ostream</strong>&nbsp;.&nbsp;Говорят, что объект cerr прикреплен к стандартным устройству ошибок, которое также является экраном дисплея, но объект&nbsp;<strong>cerr</strong>&nbsp;не забуферирован, и каждая вставка потока в cerr вызывает немедленный вывод его вывода.</p>

<p><strong>Сегг</strong>&nbsp;также используется в сочетании с оператором вставки потока ,&nbsp;как показано в следующем примере.</p>

<blockquote>
<pre>
<code>#include &lt;iostream&gt;
 
using namespace std;
 
int main() {
   char str[] = &quot;Unable to read....&quot;;
 
   cerr &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;
}</code></pre>
</blockquote>

<p>Когда приведенный выше код компилируется и выполняется, он производит следующий результат:</p>

<pre>
<code>Error message : Unable to read....</code></pre>

<h2>Стандартный поток журнала (засорение)</h2>

<p><strong>Предопределенный</strong>&nbsp;объект&nbsp;<strong>clog</strong>&nbsp;является экземпляром&nbsp;класса&nbsp;<strong>ostream</strong>&nbsp;.&nbsp;Объект clog, как говорят, прикреплен к стандартному устройству ошибок, который также является экраном дисплея, но&nbsp;<strong>затвор</strong>&nbsp;объекта&nbsp;буферизуется.&nbsp;Это означает, что каждая вставка для блокировки может привести к тому, что ее вывод будет удерживаться в буфере до заполнения буфера или до тех пор, пока буфер не будет сброшен.</p>

<p><strong>Засорить</strong>&nbsp;также используется в сочетании с оператором вставки потока ,&nbsp;как показано в следующем примере.</p>

<blockquote>
<pre>
<code>#include &lt;iostream&gt;
 
using namespace std;
 
int main() {
   char str[] = &quot;Unable to read....&quot;;
 
   clog &lt;&lt; &quot;Error message : &quot; &lt;&lt; str &lt;&lt; endl;
}</code></pre>
</blockquote>

<p>Когда приведенный выше код компилируется и выполняется, он производит следующий результат:</p>

<blockquote>
<pre>
<code>Error message : Unable to read....</code></pre>
</blockquote>

<p>Вы не сможете увидеть какие-либо различия в cout, cerr и clog с этими небольшими примерами, но при написании и выполнении больших программ разница становится очевидной.&nbsp;Поэтому хорошей практикой является отображение сообщений об ошибках с использованием потока cerr и при отображении других сообщений журнала, которые следует использовать.</p>
</div>
