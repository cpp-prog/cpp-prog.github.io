<h1>C++ - Классы хранения</h1>

<div class="tutorial-content">
<p>Класс хранения определяет область видимости и продолжительность жизни переменных и / или функций в программе C ++.&nbsp;Эти спецификаторы предшествуют типу, который они изменяют.&nbsp;Существуют следующие классы хранения, которые могут использоваться в программе на C ++</p>

<ul>
	<li>auto</li>
	<li>register</li>
	<li>static</li>
	<li>extern</li>
	<li>mutable</li>
</ul>

<h2>Автомобильный класс хранения</h2>

<p>Класс&nbsp;<strong>auto</strong>&nbsp;хранения - это класс хранения по умолчанию для всех локальных переменных.</p>

<blockquote>
<pre>
<code>{
   int mount;
   auto int month;
}</code></pre>
</blockquote>

<p>В приведенном выше примере определяются две переменные с одним и тем же классом хранения, auto может использоваться только в пределах функций, то есть локальных переменных.</p>

<h2>Класс хранения регистров</h2>

<p>Класс&nbsp;хранения&nbsp;r<strong>egister</strong>&nbsp;используется для определения локальных переменных, которые должны храниться в регистре вместо ОЗУ.&nbsp;Это означает, что переменная имеет максимальный размер, равный размеру регистра (обычно одно слово) и не может быть применен к нему унарный оператор &laquo;&amp;&raquo; (так как он не имеет ячейки памяти).</p>

<blockquote>
<pre>
<code>{
   register int  miles;
}</code></pre>
</blockquote>

<p>Регистр должен использоваться только для переменных, требующих быстрого доступа, таких как счетчики.&nbsp;Следует также отметить, что определение &laquo;register&raquo; не означает, что переменная будет сохранена в регистре.&nbsp;Это означает, что он МОЖЕТ быть сохранен в регистре в зависимости от ограничений на оборудование и реализацию.</p>

<h2>Статический класс хранения</h2>

<p><strong>static&nbsp;</strong>класс хранения инструктирует компилятор ,&nbsp;чтобы сохранить локальную переменную в существовании в&nbsp;течение всего срока реализации программы ,&nbsp;а не создавать и уничтожать его каждый раз , когда&nbsp;он приходит в и выходит из области видимости.&nbsp;Поэтому статические локальные переменные позволяют им поддерживать свои значения между вызовами функций.</p>

<p>Статический модификатор также может применяться к глобальным переменным.&nbsp;Когда это будет сделано, это приведет к тому, что область переменной будет ограничена файлом, в котором она объявлена.</p>

<p>В C ++, когда static используется для элемента данных класса, он вызывает только одну копию этого члена для общего доступа всеми объектами своего класса.</p>

<blockquote>
<pre>
<code>#include &lt;iostream&gt;
 
// Function declaration
void func(void);
 
static int count = 10; /* Global variable */
 
main() {
   while(count--) {
      func();
   }
   
   return 0;
}

// Function definition
void func( void ) {
   static int i = 5; // local static variable
   i++;
   std::cout &lt;&lt; &quot;i is &quot; &lt;&lt; i ;
   std::cout &lt;&lt; &quot; and count is &quot; &lt;&lt; count &lt;&lt; std::endl;
}</code></pre>
</blockquote>

<p>Когда приведенный выше код компилируется и выполняется, он производит следующий результат:</p>

<blockquote>
<pre>
<code>i is 6 and count is 9
i is 7 and count is 8
i is 8 and count is 7
i is 9 and count is 6
i is 10 and count is 5
i is 11 and count is 4
i is 12 and count is 3
i is 13 and count is 2
i is 14 and count is 1
i is 15 and count is 0</code></pre>
</blockquote>

<h2>Внешний класс хранения</h2>

<p>Класс&nbsp;<strong>extern</strong>&nbsp;storage используется для указания ссылки на глобальную переменную, которая видна для ВСЕХ файлов программы.&nbsp;Когда вы используете &laquo;extern&raquo;, переменная не может быть инициализирована, поскольку все, что она делает, указывает имя переменной в ранее определенном месте хранения.</p>

<p>Когда у вас несколько файлов, и вы определяете глобальную переменную или функцию, которые будут использоваться и в других файлах, то&nbsp;<em>extern</em>будет использоваться в другом файле, чтобы дать ссылку на определенную переменную или функцию.&nbsp;Просто для понимания&nbsp;<em>extern</em>используется для объявления глобальной переменной или функции в другом файле.</p>

<p>Модификатор extern наиболее часто используется, когда есть два или более файла, которые используют одни и те же глобальные переменные или функции, как описано ниже.</p>

<h3>Первый файл: main.cpp</h3>

<blockquote>
<pre>
<code>#include &lt;iostream&gt;
int count ;
extern void write_extern();
 
main() {
   count = 5;
   write_extern();
}</code></pre>

<p>&nbsp;Второй файл: support.cpp</p>

<pre>
<code>#include &lt;iostream&gt;

extern int count;

void write_extern(void) {
   std::cout &lt;&lt; &quot;Count is &quot; &lt;&lt; count &lt;&lt; std::endl;
}</code></pre>
</blockquote>

<p>Здесь&nbsp;ключевое слово&nbsp;<em>extern</em>&nbsp;используется для объявления <code>count</code> в другом файле.&nbsp;Теперь скомпилируйте эти два файла следующим образом:</p>

<blockquote>
<pre>
<code>$g++ main.cpp support.cpp -o write</code></pre>
</blockquote>

<p>Это даст&nbsp;написать&nbsp;исполняемую программу, попытайтесь выполнить&nbsp;запись&nbsp;и проверьте результат следующим образом:</p>

<blockquote>
<pre>
<code>$./write
5</code></pre>
</blockquote>

<h2>Изменчивый класс хранения</h2>

<p>Спецификатор&nbsp;<code>mutable</code>&nbsp;применяется только к объектам класса, которые рассматриваются ниже в этом уроке.&nbsp;Он позволяет члену объекта переопределять функцию-член-член.&nbsp;То есть, изменяемый член может быть модифицирован функцией-членом-константой.</p>
</div>
