<h1>C++ - Операторы</h1>

<p>Оператор - это символ, который сообщает компилятору выполнить определенные математические или логические манипуляции.&nbsp;C ++ богат встроенными операторами и предоставляет следующие типы операторов:</p>

<ul>
	<li>Арифметические операторы</li>
	<li>Реляционные операторы</li>
	<li>Логические операторы</li>
	<li>Побитовые операторы</li>
	<li>Операторы присваивания</li>
	<li>Другие операторы</li>
</ul>

<h2>Арифметические операторы</h2>

<p>Существуют следующие арифметические операторы, поддерживаемые языком C ++:</p>

<table style="width:100%">
	<tbody>
		<tr>
			<th>Оператор</th>
			<th>Описание</th>
			<th>Пример</th>
		</tr>
		<tr>
			<td>+</td>
			<td>Добавляет два операнда</td>
			<td>A + B даст 30</td>
		</tr>
		<tr>
			<td>-</td>
			<td>Вычитает второй операнд с первого</td>
			<td>A - B даст -10</td>
		</tr>
		<tr>
			<td>*</td>
			<td>Умножает оба операнда</td>
			<td>A * B даст 200</td>
		</tr>
		<tr>
			<td>/</td>
			<td>Делит числитель на де-числитель</td>
			<td>B / A даст 2</td>
		</tr>
		<tr>
			<td>%</td>
			<td>Оператор модуля и остаток после целочисленного деления</td>
			<td>B% A даст 0</td>
		</tr>
		<tr>
			<td>++</td>
			<td>Оператор приращения увеличивает целочисленное значение на единицу</td>
			<td>A ++ даст 11</td>
		</tr>
		<tr>
			<td>-</td>
			<td>Уменьшает целочисленное значение на единицу</td>
			<td>A-- даст 9</td>
		</tr>
	</tbody>
</table>

<h2>Реляционные операторы</h2>

<p>Существуют следующие реляционные операторы, поддерживаемые языком C ++:</p>

<table style="width:100%">
	<tbody>
		<tr>
			<th>Оператор</th>
			<th>Описание</th>
			<th>Пример</th>
		</tr>
		<tr>
			<td>==</td>
			<td>Проверяет, равны ли значения двух операндов или нет, если да, то условие становится истинным.</td>
			<td>(A == B) не соответствует действительности.</td>
		</tr>
		<tr>
			<td>знак равно</td>
			<td>Проверяет, равны ли значения двух операндов или нет, если значения не равны, условие становится истинным.</td>
			<td>(A! = B) истинно.</td>
		</tr>
		<tr>
			<td>&gt;</td>
			<td>Проверяет, превышает ли значение левого операнда значение правого операнда, если да, тогда условие становится истинным.</td>
			<td>(A&gt; B) неверно.</td>
		</tr>
		<tr>
			<td>&lt;</td>
			<td>Проверяет, является ли значение левого операнда меньше значения правильного операнда, если да, тогда условие становится истинным.</td>
			<td>(A &lt;B) истинно.</td>
		</tr>
		<tr>
			<td>&gt; =</td>
			<td>Проверяет, превышает ли значение левого операнда значение правого операнда, если да, тогда условие становится истинным.</td>
			<td>(A&gt; = B) неверно.</td>
		</tr>
		<tr>
			<td>&lt;=</td>
			<td>Проверяет, является ли значение левого операнда меньше или равно значению правильного операнда, если да, тогда условие становится истинным.</td>
			<td>(A &lt;= B) истинно.</td>
		</tr>
	</tbody>
</table>

<h2>Логические операторы</h2>

<p>Существуют следующие логические операторы, поддерживаемые языком C ++:</p>

<table style="width:100%">
	<tbody>
		<tr>
			<th>Оператор</th>
			<th>Описание</th>
			<th>Пример</th>
		</tr>
		<tr>
			<td>&amp;&amp;</td>
			<td>Вызывается логическим оператором AND.&nbsp;Если оба операнда отличны от нуля, условие становится истинным.</td>
			<td>(A &amp;&amp; B) является ложным.</td>
		</tr>
		<tr>
			<td>||</td>
			<td>Вызывается логическим оператором ИЛИ.&nbsp;Если любой из двух операндов отличен от нуля, тогда условие становится истинным.</td>
			<td>(A || B) истинно.</td>
		</tr>
		<tr>
			<td>!</td>
			<td>Вызывается логическим оператором NOT.&nbsp;Используется для изменения логического состояния операнда.&nbsp;Если условие истинно, то логический оператор NOT сделает ложным.</td>
			<td>! (A &amp;&amp; B) истинно.</td>
		</tr>
	</tbody>
</table>

<h2>Побитовые операторы</h2>

<p>Побитовый оператор работает с битами и выполняет побитовую операцию.&nbsp;Таблицы истинности для &amp;, |, и ^ заключаются в следующем:</p>

<table style="width:100%">
	<tbody>
		<tr>
			<th>p</th>
			<th>q</th>
			<th>p &amp; q</th>
			<th>p | q</th>
			<th>p ^ q</th>
		</tr>
		<tr>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
			<td>0</td>
		</tr>
		<tr>
			<td>0</td>
			<td>1</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
		</tr>
		<tr>
			<td>1</td>
			<td>1</td>
			<td>1</td>
			<td>1</td>
			<td>0</td>
		</tr>
		<tr>
			<td>1</td>
			<td>0</td>
			<td>0</td>
			<td>1</td>
			<td>1</td>
		</tr>
	</tbody>
</table>

<p>Побитовые операторы, поддерживаемые языком C ++, перечислены в следующей таблице:</p>

<table style="width:100%">
	<tbody>
		<tr>
			<th>Оператор</th>
			<th>Описание</th>
			<th>Пример</th>
		</tr>
		<tr>
			<td>&amp;</td>
			<td>Двоичный оператор AND копирует бит в результат, если он существует в обоих операндах.</td>
			<td>(A &amp; B) даст 12, что составляет 0000 1100</td>
		</tr>
		<tr>
			<td>|</td>
			<td>Двоичный оператор OR копирует бит, если он существует в любом из операндов.</td>
			<td>(A | B) даст 61, который равен 0011 1101</td>
		</tr>
		<tr>
			<td>^</td>
			<td>Оператор двоичного XOR копирует бит, если он установлен в один операнд, но не тот и другой.</td>
			<td>(A ^ B) даст 49, который равен 0011 0001</td>
		</tr>
		<tr>
			<td>~</td>
			<td>Binary Ones Оператор дополнения является унарным и имеет эффект &laquo;flipping&raquo; бит.</td>
			<td>(~ A) даст -61, что составляет 1100 0011 в форме дополнения 2 из-за подписанного двоичного числа.</td>
		</tr>
		<tr>
			<td>&lt;&lt;</td>
			<td>Двойной левый оператор сдвига.Значение левых операндов перемещается влево на количество бит, заданных правым операндом.</td>
			<td>A &lt;&lt; 2 даст 240, что составляет 1111 0000</td>
		</tr>
		<tr>
			<td>&gt;&gt;</td>
			<td>Двоичный оператор правого сдвига.&nbsp;Значение левых операндов перемещается вправо на количество бит, заданных правым операндом.</td>
			<td>A &gt;&gt; 2 даст 15, что составляет 0000 1111</td>
		</tr>
	</tbody>
</table>

<h2>Операторы присваивания</h2>

<p>Существуют следующие операторы присваивания, поддерживаемые языком C ++:</p>

<table style="width:100%">
	<tbody>
		<tr>
			<th>Оператор</th>
			<th>Описание</th>
			<th>Пример</th>
		</tr>
		<tr>
			<td>знак равно</td>
			<td>Простой оператор присваивания, присваивает значения из правых операндов в левый операнд.</td>
			<td>C = A + B присваивает значение A + B в C</td>
		</tr>
		<tr>
			<td>+ =</td>
			<td>Оператор Add AND присваивания, Он добавляет правый операнд в левый операнд и присваивает результат левому операнду.</td>
			<td>C + = A эквивалентно C = C + A</td>
		</tr>
		<tr>
			<td>знак равно</td>
			<td>Subtract AND assign operator, вычитает правый операнд из левого операнда и присваивает результат левому операнду.</td>
			<td>C - = A эквивалентно C = C - A</td>
		</tr>
		<tr>
			<td>знак равно</td>
			<td>Оператор умножения и присваивания, Он умножает правый операнд на левый операнд и присваивает результат левому операнду.</td>
			<td>C * = A эквивалентно C = C * A</td>
		</tr>
		<tr>
			<td>знак равно</td>
			<td>Оператор Divide AND assign. Он делит левый операнд на правый операнд и присваивает результат левому операнду.</td>
			<td>C / = A эквивалентно C = C / A</td>
		</tr>
		<tr>
			<td>знак равно</td>
			<td>Модуль и оператор присваивания, он принимает модуль с использованием двух операндов и присваивает результат левому операнду.</td>
			<td>C% = A эквивалентно C = C% A</td>
		</tr>
		<tr>
			<td>&lt;&lt; =</td>
			<td>Оператор сдвига слева и.</td>
			<td>C &lt;&lt; = 2 совпадает с C = C &lt;&lt; 2</td>
		</tr>
		<tr>
			<td>&gt;&gt; =</td>
			<td>Оператор правой смещения и назначения.</td>
			<td>C &gt;&gt; = 2 совпадает с C = C &gt;&gt; 2</td>
		</tr>
		<tr>
			<td>знак равно</td>
			<td>Побитовый И оператор присваивания.</td>
			<td>C &amp; = 2 является таким же, как C = C &amp; 2</td>
		</tr>
		<tr>
			<td>^ =</td>
			<td>Побитовое исключающее ИЛИ и оператор присваивания.</td>
			<td>C ^ = 2 является таким же, как C = C ^ 2</td>
		</tr>
		<tr>
			<td>| =</td>
			<td>Побитовое включение оператора OR и присваивания.</td>
			<td>C | = 2 совпадает с C = C |2</td>
		</tr>
	</tbody>
</table>

<h2>Другие операторы</h2>

<p>В следующей таблице перечислены некоторые другие операторы, поддерживаемые C ++:</p>

<table style="width:100%">
	<tbody>
		<tr>
			<th>Оператор</th>
			<th>Описание</th>
		</tr>
		<tr>
			<td><strong>sizeof</strong></td>
			<td>
			<p>Возвращает размер переменной.&nbsp;Например, sizeof (a), где &#39;a&#39; является целым числом и будет возвращать 4.</p>
			</td>
		</tr>
		<tr>
			<td><strong>Condition ? X : Y</strong></td>
			<td>
			<p>Если Условие истинно, то оно возвращает значение X, иначе возвращает значение Y.</p>
			</td>
		</tr>
		<tr>
			<td><strong>,</strong></td>
			<td>
			<p>Вызывает последовательность операций.&nbsp;Значение всего выражения запятой - это значение последнего выражения списка, разделенного запятыми.</p>
			</td>
		</tr>
		<tr>
			<td><strong>. (dot) and -&gt; (arrow)</strong></td>
			<td>
			<p>Используются для ссылки на отдельных членов классов, структур и союзов.</p>
			</td>
		</tr>
		<tr>
			<td><strong>Cast</strong></td>
			<td>
			<p>Преобразуют один тип данных в другой.&nbsp;Например, int (2.2000) вернет 2.</p>
			</td>
		</tr>
		<tr>
			<td><strong>&amp;</strong></td>
			<td>
			<p>Возвращает адрес переменной.&nbsp;Например, &amp; a;&nbsp;даст фактический адрес переменной.</p>
			</td>
		</tr>
		<tr>
			<td><strong>*</strong></td>
			<td>
			<p>Является указателем на переменную.&nbsp;Например * var;&nbsp;будет указывать на переменную var.</p>
			</td>
		</tr>
	</tbody>
</table>

<h2>Приоритеты операторов в C ++</h2>

<p>Приоритет оператора определяет группировку терминов в выражении.&nbsp;Это влияет на оценку выражения.&nbsp;Некоторые операторы имеют более высокий приоритет, чем другие;&nbsp;например, оператор умножения имеет более высокий приоритет, чем оператор сложения -</p>

<p>Например, x = 7 + 3 * 2;&nbsp;здесь x назначается 13, а не 20, потому что оператор * имеет более высокий приоритет, чем +, поэтому он сначала умножается на 3 * 2, а затем добавляется в 7.</p>

<p>Здесь операторы с наивысшим приоритетом появляются в верхней части таблицы, а нижние - внизу.&nbsp;Внутри выражения сначала будут оцениваться операторы с более высоким приоритетом.</p>

<table style="width:100%">
	<tbody>
		<tr>
			<th>Категория&nbsp;</th>
			<th>Оператор&nbsp;</th>
			<th>Ассоциативность&nbsp;</th>
		</tr>
		<tr>
			<td>постфикс&nbsp;</td>
			<td>() [] -&gt;.&nbsp;++ - - &nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>Одинарный&nbsp;</td>
			<td>+ -!&nbsp;~ ++ - - (тип) * &amp; sizeof&nbsp;</td>
			<td>Справа налево&nbsp;</td>
		</tr>
		<tr>
			<td>Multiplicative &nbsp;</td>
			<td>* /%&nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>присадка &nbsp;</td>
			<td>+ -&nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>сдвиг &nbsp;</td>
			<td>&lt;&lt; &gt;&gt;&nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>реляционный &nbsp;</td>
			<td>&lt;&lt;=&gt;&gt; =&nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>равенство &nbsp;</td>
			<td>==! =&nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>Побитовое AND&nbsp;</td>
			<td>&amp;&nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>Побитовое XOR&nbsp;</td>
			<td>^&nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>Побитовое OR&nbsp;</td>
			<td>|&nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>Логические AND&nbsp;</td>
			<td>&amp;&amp;&nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>Логический OR&nbsp;</td>
			<td>||&nbsp;</td>
			<td>Слева направо&nbsp;</td>
		</tr>
		<tr>
			<td>условный&nbsp;</td>
			<td>?:&nbsp;</td>
			<td>Справа налево&nbsp;</td>
		</tr>
		<tr>
			<td>присваивание&nbsp;</td>
			<td>= + = - = * = / =% = &gt;&gt; = &lt;&lt; = &amp; = ^ = | =&nbsp;</td>
			<td>Справа налево&nbsp;</td>
		</tr>
		<tr>
			<td>запятая&nbsp;</td>
			<td>,&nbsp;</td>
			<td>Слева направо</td>
		</tr>
	</tbody>
</table>
