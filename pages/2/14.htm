<h1>C ++ - Функции</h1>

<p>Функция представляет собой группу операторов, которые вместе выполняют задачу.&nbsp;Каждая программа на C ++ имеет по крайней мере одну функцию, которая является&nbsp;<code>main ()</code>&nbsp;, и все тривиальные программы могут определять дополнительные функции.</p>

<p>Вы можете разделить свой код на отдельные функции.&nbsp;Как вы разделяете свой код между различными функциями, зависит от вас, но логически разделение обычно таково, что каждая функция выполняет определенную задачу.</p>

<p>Функция&nbsp;<code>declaration</code>&nbsp;сообщает компилятор об имени функции во, типе возвращаемого значения и параметрах.&nbsp;Функция&nbsp;<code>definition</code><strong>&nbsp;</strong>обеспечивает реальное тело функции.</p>

<p>Стандартная библиотека C ++ предоставляет множество встроенных функций, которые может вызывать ваша программа.&nbsp;Например, функция&nbsp;<code>strcat ()</code>&nbsp;для объединения двух строк, функция&nbsp;<code>memcpy()</code>&nbsp;для копирования одной ячейки памяти в другое место и множество других функций.</p>

<p>Функция известна с различными именами, такими как метод или подпрограмма или процедура и т. д.</p>

<h2>Определение функции</h2>

<p>Общая форма определения функции C ++ заключается в следующем:</p>

<blockquote>
<pre>
<code>return_type function_name( parameter list ) {
   body of the function
}</code></pre>
</blockquote>

<p>Определение функции C ++ состоит из заголовка функции и тела функции.&nbsp;Вот все части функции -</p>

<ul>
	<li><code>Return Type.</code> Функция может возвращать значение.&nbsp;Тип&nbsp;<code>return_type</code>&nbsp;- это тип данных значения, возвращаемого функцией.&nbsp;Некоторые функции выполняют требуемые операции без возврата значения.&nbsp;В этом случае return_type является ключевым словом&nbsp;<code>void</code>&nbsp;.</li>
	<li><code>Function Name</code>&nbsp;- это фактическое имя функции.&nbsp;Имя функции и список параметров вместе составляют подпись функции.</li>
	<li><code>Parameters</code>. Параметр подобен заполнителю.&nbsp;Когда функция вызывается, вы передаете значение параметру.&nbsp;Это значение называется фактическим параметром или аргументом.&nbsp;Список параметров относится к типу, порядку и количеству параметров функции.&nbsp;Параметры являются необязательными;&nbsp;то есть функция не может содержать никаких параметров.</li>
	<li><code>Function Body.</code> Тело&nbsp;функции содержит набор операторов, которые определяют, что делает функция.</li>
</ul>

<h2>Пример</h2>

<p>Ниже приведен исходный код для функции&nbsp;<code>max ()</code>&nbsp;.&nbsp;Эта функция принимает два параметра num1 и num2 и возвращает наибольшую из них:</p>

<blockquote>
<pre>
<code>int max(int num1, int num2) {
   int result;
 
   if (num1 &gt; num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}</code></pre>
</blockquote>

<h2>Объявление функций</h2>

<p>Функция&nbsp;<strong>декларация</strong>&nbsp;сообщает компилятор о имени функции и как вызвать функцию.&nbsp;Фактическое тело функции можно определить отдельно.</p>

<p>Объявление функции имеет следующие части -</p>

<blockquote>
<pre>
<code>return_type function_name( parameter list );</code></pre>
</blockquote>

<p>Для указанной выше функции max () следующим является объявление функции -</p>

<blockquote>
<pre>
<code>int max(int num1, int num2);</code></pre>
</blockquote>

<p>Имена параметров не важны в объявлении функции только для их типа, поэтому следующее также является действительным объявлением -</p>

<blockquote>
<pre>
<code>int max(int, int);</code></pre>
</blockquote>

<p>Объявление функции требуется при определении функции в одном исходном файле, и вы вызываете эту функцию в другом файле.&nbsp;В таком случае вы должны объявить функцию в верхней части файла, вызывающего функцию.</p>

<h2>Вызов функции</h2>

<p>При создании функции C ++ вы даете определение того, что должна делать функция.&nbsp;Чтобы использовать функцию, вам придется вызвать или вызвать эту функцию.</p>

<p>Когда программа вызывает функцию, управление программой передается вызываемой функции.&nbsp;Вызываемая функция выполняет определенную задачу, и когда выполняется оператор return или когда достигается завершающая ее конечная скобка, она возвращает управление программой обратно в основную программу.</p>

<p>Чтобы вызвать функцию, вам просто нужно передать необходимые параметры вместе с именем функции, а если функция возвращает значение, вы можете сохранить возвращаемое значение.&nbsp;Например,</p>

<blockquote>
<pre>
<code>#include &lt;iostream&gt;
using namespace std;
 
// function declaration
int max(int num1, int num2);
 
int main () {
   // local variable declaration:
   int a = 100;
   int b = 200;
   int ret;
 
   // calling a function to get max value.
   ret = max(a, b);
   cout &lt;&lt; &quot;Max value is : &quot; &lt;&lt; ret &lt;&lt; endl;
 
   return 0;
}
 
// function returning the max between two numbers
int max(int num1, int num2) {
   // local variable declaration
   int result;
 
   if (num1 &gt; num2)
      result = num1;
   else
      result = num2;
 
   return result; 
}</code></pre>
</blockquote>

<h2>Аргументы функции</h2>

<p>Если функция использует аргументы, она должна объявлять переменные, принимающие значения аргументов.&nbsp;Эти переменные называются&nbsp;<strong>формальными параметрами</strong>&nbsp;функции.</p>

<p>Формальные параметры ведут себя как другие локальные переменные внутри функции и создаются при входе в функцию и уничтожаются при выходе.</p>

<p>При вызове функции существует два способа передачи аргументов функции -</p>

<table border="1" cellpadding="1" cellspacing="1">
	<tbody>
		<tr>
			<td>Call by Value (Вызов по значению)</td>
			<td>Этот метод копирует фактическое значение аргумента в формальный параметр функции.&nbsp;В этом случае изменения, внесенные в параметр внутри функции, не влияют на аргумент.</td>
		</tr>
		<tr>
			<td>Call by Pointer (Вызов по указателю)</td>
			<td>Этот метод копирует адрес аргумента в формальный параметр.&nbsp;Внутри функции адрес используется для доступа к фактическому аргументу, используемому в вызове.&nbsp;Это означает, что изменения, внесенные в параметр, влияют на аргумент.</td>
		</tr>
		<tr>
			<td>Call by Reference (Вызов по ссылке)</td>
			<td>Этот метод копирует ссылку аргумента в формальный параметр.&nbsp;Внутри функции ссылка используется для доступа к фактическому аргументу, используемому в вызове.&nbsp;Это означает, что изменения, внесенные в параметр, влияют на аргумент.</td>
		</tr>
	</tbody>
</table>

<p>По умолчанию C ++ использует&nbsp;<strong>вызов по значению</strong>&nbsp;для передачи аргументов.&nbsp;В общем, это означает, что код внутри функции не может изменять аргументы, используемые для вызова функции и вышеупомянутого примера, при вызове функции max (), используемой тем же методом.</p>

<h2>Значения по умолчанию для параметров</h2>

<p>Когда вы определяете функцию, вы можете указать значение по умолчанию для каждого из последних параметров.&nbsp;Это значение будет использоваться, если соответствующий аргумент остается пустым при вызове функции.</p>

<p>Это делается с помощью оператора присваивания и назначения значений для аргументов в определении функции.&nbsp;Если значение для этого параметра не передается при вызове функции, используется заданное по умолчанию значение, но если задано значение, это значение по умолчанию игнорируется и вместо этого используется переданное значение.&nbsp;Рассмотрим следующий пример:</p>

<blockquote>
<pre>
<code>#include &lt;iostream&gt;
using namespace std;
 
int sum(int a, int b = 20) {
   int result;
   result = a + b;
  
   return (result);
}
int main () {
   // local variable declaration:
   int a = 100;
   int b = 200;
   int result;
 
   // calling a function to add the values.
   result = sum(a, b);
   cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;

   // calling a function again as follows.
   result = sum(a);
   cout &lt;&lt; &quot;Total value is :&quot; &lt;&lt; result &lt;&lt; endl;
 
   return 0;
}</code></pre>
</blockquote>

<p>Когда приведенный выше код компилируется и выполняется, он производит следующий результат:</p>

<blockquote>
<pre>
<code>Total value is :300
Total value is :120</code></pre>
</blockquote>
