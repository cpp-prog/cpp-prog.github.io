<h1>C ++ - Интерфейсы (абстрактные классы)</h1>

<div class="tutorial-content">
<p>Интерфейс описывает поведение или возможности класса C ++, не связываясь с конкретной реализацией этого класса.</p>

<p>Интерфейсы C ++ реализуются с использованием&nbsp;<strong>абстрактных классов,</strong>и эти абстрактные классы не следует путать с абстракцией данных, которая представляет собой концепцию сохранения деталей реализации отдельно от связанных данных.</p>

<p>Класс делается абстрактным, объявляя хотя бы одну из своих функций&nbsp;<strong>чистой виртуальной</strong>&nbsp;функцией.&nbsp;Чистая виртуальная функция задается путем размещения в объявлении &laquo;= 0&raquo; следующим образом:</p>

<blockquote>
<pre>
<code>class Box {
   public:
      // pure virtual function
      virtual double getVolume() = 0;
      
   private:
      double length;      // Length of a box
      double breadth;     // Breadth of a box
      double height;      // Height of a box
};</code></pre>
</blockquote>

<p>Цель&nbsp;<strong>абстрактного класса</strong>&nbsp;(часто называемого ABC) заключается в предоставлении соответствующего базового класса, из которого могут наследовать другие классы.&nbsp;Абстрактные классы не могут использоваться для создания объектов и служат только как&nbsp;<strong>интерфейс</strong>&nbsp;.&nbsp;Попытка создать экземпляр объекта абстрактного класса вызывает ошибку компиляции.</p>

<p>Таким образом, если подкласс ABC необходимо создать, он должен реализовать каждую из виртуальных функций, а это означает, что он поддерживает интерфейс, объявленный ABC.&nbsp;Невозможность переопределить чистую виртуальную функцию в производном классе, а затем попытаться создать объекты этого класса, является ошибкой компиляции.</p>

<p>Классы, которые могут использоваться для создания объектов, называются&nbsp;<strong>конкретными классами</strong>&nbsp;.</p>

<h2>Пример абстрактного класса</h2>

<p>Рассмотрим следующий пример, когда родительский класс предоставляет интерфейс базовому классу для реализации функции&nbsp;<strong>getArea ()</strong>&nbsp;-</p>

<blockquote>
<pre>
<code>#include &lt;iostream&gt;
 
using namespace std;
 
// Base class
class Shape {
   public:
      // pure virtual function providing interface framework.
      virtual int getArea() = 0;
      void setWidth(int w) {
         width = w;
      }
   
      void setHeight(int h) {
         height = h;
      }
   
   protected:
      int width;
      int height;
};
 
// Derived classes
class Rectangle: public Shape {
   public:
      int getArea() { 
         return (width * height); 
      }
};

class Triangle: public Shape {
   public:
      int getArea() { 
         return (width * height)/2; 
      }
};
 
int main(void) {
   Rectangle Rect;
   Triangle  Tri;
 
   Rect.setWidth(5);
   Rect.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; &quot;Total Rectangle area: &quot; &lt;&lt; Rect.getArea() &lt;&lt; endl;

   Tri.setWidth(5);
   Tri.setHeight(7);
   
   // Print the area of the object.
   cout &lt;&lt; &quot;Total Triangle area: &quot; &lt;&lt; Tri.getArea() &lt;&lt; endl; 

   return 0;
}</code></pre>
</blockquote>

<p>Когда приведенный выше код компилируется и выполняется, он производит следующий результат:</p>

<blockquote>
<pre>
<code>Total Rectangle area: 35
Total Triangle area: 17</code></pre>
</blockquote>

<p>Вы можете видеть, как абстрактный класс определял интерфейс с точки зрения getArea (), а два других класса реализовали одну и ту же функцию, но с другим алгоритмом для вычисления области, специфичной для формы.</p>

<h2>Стратегия проектирования</h2>

<p>Объектно-ориентированная система может использовать абстрактный базовый класс для обеспечения общего и стандартизованного интерфейса, подходящего для всех внешних приложений.&nbsp;Затем через наследование от этого абстрактного базового класса формируются производные классы, которые действуют аналогичным образом.</p>

<p>Возможности (т. е. публичные функции), предлагаемые внешними приложениями, предоставляются в виде чистых виртуальных функций в абстрактном базовом классе.&nbsp;Реализации этих чистых виртуальных функций предоставляются в производных классах, которые соответствуют конкретным типам приложения.</p>

<p>Эта архитектура также позволяет легко добавлять новые приложения в систему даже после того, как система была определена.</p>
</div>
